##### 如何保证消息不丢失

RabbitMQ 消息丢失的情况主要有如下几种，针对不同的丢失情况有不同的应对策略：

1. 生产者到 RabbitMQ 的过程中丢失

    - 生产者到交换机的过程中丢失
        - 通过消息发布确认机制 Publisher Confirm，确保消息成功被投递到交换机，并收到 ACK 回执。如果消息未投递到交换机，将返回 NACK。

    - 交换机到队列的过程中丢失

        - 使用发送者回执机制来确认消息有没有成功从交换机路由到队列。如果消息未成功到达队列，将返回 ACK，以及路由失败的原因。

      > 注意：
      >
      > 1. 在启用确认机制的时候，需要给每个消息设置一个全局唯一的ID，以区分不同的消息，避免 ACK 冲突。
      > 2. 即使交换机和队列都是 RabbitMQ 内部的组件，但考虑到交换机并不持久化存储消息，所以实际上发布者确认机制主要是用来避免在生产者到 RabbitMQ 的过程中消息丢失的情况而不是防止消息在 RabbitMQ 内部丢失的情况。

2. 消息在 RabbitMQ 内部丢失
    - 消息持久化
        - 交换机持久化
        - 队列持久化
        - 消息持久化

3. RabbitMQ到消费者的过程中丢失

    - 消费者消息确认机制
        - 开启消费者消息确认机制为 auto 模式，RabbitMQ 通过消费者回执来确认消费者是否成功处理消息；消费者获取消息后，应该向 RabbitMQ 发送 ACK 回执，表明已经处理消息。
        - 消费者消息确认机制中的 auto 模式可能导致消费者拿去消息，回滚消息，消息重新入队，消费者重新拿去等操作不断循环，资源占用飙升，导致消息中间件服务稳定性受到影响。
        - auto 模式需要搭配本地重试，通过本地重试机制给失败重试添加上限。
        - 本地重试机制需要搭配 MessageRecoverer 策略，它提供了三种实现，通常采用 RepublishMessageRecoverer ，表明失败重试达到本地重试设定的阈值后触发的策略：重试耗尽后，将失败消息投递到指定的交换机。
        - 通常在此处引入错误交换机（error.exchange）和错误队列（error.queue），接收重试达到上限的消息。注意错误交换机和错误队列的创建需要保证持久化，否则消息转发到此也没有意义。
        - 至于到达 error.queue 中的消息怎么处理可以按照业务需求来处理，是否持久化到磁盘，或者是否添加专用的错误消费者等。

    - 死信交换机与死信队列
        - 死信交换机和死信队列专用于处理死信，不同于错误交换机和错误队列，死信是原有的消费者主动拒绝处理或者不处理的消息，这种消息堆积在消息队列中，成为了不可能被消费的消息，这类消息是否允许丢失取决于业务设计；而错误交换机和错误队列中存放的是，原有消费者希望处理，但是由于消费者自身问题导致没有能力处理的消息，这类消息往往是不允许被丢失的。
        - 成为死信通常是因为：
            - 原消费者主动拒绝的消息，成为死信
            - 消息在生产时设定了到期时间，消息被送达队列开始到到期时间结束，消息没有被消费，成为死信
            - 消息所在的队列设定了到期时间，进入该队列的消息计时到到队列的到期时间为止，消息没有被消费，成为死信
            - 队列满员，后来的消息没有办法处理，成为死信

    - 延迟队列
        - 通过创建延迟交换机，发送消息时设置消息属性 header 值为 x-delay ，当带有该属性的消息进入延迟交换机时，消息会被持久化到磁盘中，x-delay的值会被读取作为延迟时间，返回routing not found结果给消息发送者，x-delay时间到期后，重新投递消息到指定队列
        - 通过延迟队列，实现对高峰期时间段的非核心业务延迟处理，机器资源更充分的用来处理高并发任务

    - 惰性队列
        - 当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题
        - 解决消息堆积问题通常采用如下方案：
            - 增加更多消费者，提高消费速度，即采用work queue模式
            - 加大服务器内存，扩大队列容积（硬件成本）
            - 引入惰性队列，惰性队列将多余的信息持久化保存到磁盘中，将服务器并发压力和内存压力转为磁盘IO压力

4. 集群（硬件成本）

    - 镜像集群与消息复制

        - 在一个 RabbitMQ 集群中，交换器和队列的信息是在所有节点中共享的，但对于消息，它们默认只存在于它们首次发布的那个节点上。这就意味着，如果那个节点宕机了，那么它上面的消息都将会丢失。
        - 为了解决这个问题，RabbitMQ 提供了消息复制功能。可以把队列设置为 “镜像模式”，在这种模式下，所有的消息发布到该队列上的动作都会被复制到所有的节点上，这就确保了即使某个节点宕机，消息仍然可以从其他节点上获取。

    - 节点选举与仲裁队列

        - 在 RabbitMQ 集群中，一个队列可以有多个镜像，其中有一个主镜像和若干个从镜像。主镜像负责处理所有的读、写操作，而从镜像则负责复制主镜像上的操作，以保障数据的一致性。
        - 当主镜像节点由于某些原因宕机后，其中的从镜像会通过一个叫做 "仲裁" 的过程来选举新的主镜像。RabbitMQ 使用的是 Raft 改良算法，通过消息投票来选举新的主镜像，以此保证集群的高可用性和消息的不丢失。

      > 虽然仲裁队列可以提供高可用性和防止消息丢失，但是在网络分区等异常情况下，RabbitMQ 依然可能面临`脑裂`问题，可能需要额外的处理手段，如采用延迟等待网络恢复、人工干预等方式来解决。
      >
      > 脑裂：在一个由多个节点构成的集群中，由于网络问题，某些节点不能与其他节点通信，导致集群被分割为两个或多个互不连通的部分，而这些部分中的节点却都认为自己是活跃的，于是开始自行处理任务。然而，如果这些节点都对同一数据进行操作，就可能出现数据不一致的情况

    - 集群扩容，加大服务器集群的算力

